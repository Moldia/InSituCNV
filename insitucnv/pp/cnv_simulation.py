import numpy as np
import pandas as pd
from scipy.sparse import lil_matrix, csr_matrix
import random
import anndata

def generate_cnvs(CNV_dict, min_size, max_size, gene_info, save_csv = None):
    """ 
    This function generates copy number variations (CNVs) based on a dictionary (CNV_dict) of genes (keys) and whether they should be gain or loss (value). The size (bp) of the CNV is a randomly chosen between min_size and max_size. The gene will be in the center of the CNV, so half of the size (bp) is subtracted (start) and added (end) from the center of the gene position ('Gene end (bp)'- 'Gene start (bp)')/2), according to the gene_list. The function returns the CNV information as a DataFrame, specifying the gene name, chromosome, size (bp), type (gain/loss), start (bp), end (bp).

    Parameters:
        - CNV_dict (dictionary): Gene name (key) and whether they should be 'gain' or 'loss'.
        - min_size (nbr): minimum size (in bp) of the CNV.
        - max_size (nbr): maximum size (in bp) of the CNV.
        - gene_info (str): The path to the gene information from the *Ensmbl_BioMart_gene_info.txt* file, including  'Gene stable ID', 'Chromosome/scaffold name', 'Gene start (bp)', 'Gene end (bp)', 'Gene name' of the human genome GRCh38.

    Returns:
        - cnv_df (DataFrame): Compiling the gene name, chromosome, size, type, start, end
    """

    gene_info = pd.read_csv(gene_info)
    cnv_list = []

    for gene in CNV_dict:
        # Check if the gene is present in gene_info DataFrame
        if gene not in gene_info['Gene name'].values:
            print(f"Gene '{gene}' not found in gene_info DataFrame.")
            continue
        
        # Find gene details in the gene_info DataFrame
        gene_row = gene_info.loc[gene_info['Gene name'] == gene].iloc[0]
        
        # Calculate gene center
        gene_center = (gene_row['Gene end (bp)'] + gene_row['Gene start (bp)']) // 2
        
        # Randomly generate CNV size
        cnv_size = random.randint(min_size, max_size)
        
        # Calculate CNV start and end positions
        cnv_start = gene_center - cnv_size // 2
        cnv_end = gene_center + cnv_size // 2
        
        # Create CNV entry
        cnv = {
            'Gene name': gene,
            'Chromosome': gene_row['Chromosome/scaffold name'],
            'Size (bp)': cnv_size,
            'Type': CNV_dict[gene],
            'Start (bp)': cnv_start,
            'End (bp)': cnv_end
        }
        
        cnv_list.append(cnv)
    
    # Convert the list of CNV dictionaries to a DataFrame
    cnv_df = pd.DataFrame(cnv_list)

    if save_csv:
        cnv_df.to_csv(save_csv, index=None)
    
    return cnv_df



def create_cnv_template(adata, CNV_df):
    """ 
    This function generates a template for CNVs to an AnnData object.

    Parameters:
        - adata (AnnData): The AnnData object to which the CNVs should fit.
        - CNV_df (DataFrame): CNVs generated by the generate_cnvs function. 

    Returns:
        - cnv_template_df (DataFrame): A CNV template where each CNV (gene name) has a -1/0/1 value for each gene in the adata.var.
    """
    
    # Step 1: Order adata.var by chromosome and start position
    adata.var.sort_values(by=['chromosome', 'start'], inplace=True)
    
    # Initialize the CNV template matrix with zeros
    cnv_template = np.zeros((len(CNV_df), len(adata.var_names)))

    # Create a mapping of gene names to indices in the sorted AnnData object
    gene_to_index = {gene: idx for idx, gene in enumerate(adata.var_names)}

    # Step 2: Loop through each CNV in the CNV_df
    for i, row in CNV_df.iterrows():
        chromosome = row['Chromosome']
        cnv_start = row['Start (bp)']
        cnv_end = row['End (bp)']
        cnv_type = row['Type']
        
        # Find the genes in the corresponding chromosome that fall within the CNV region
        selected_genes = adata.var[
            (adata.var['chromosome'] == f"chr{chromosome}") &
            (adata.var['start'] >= cnv_start) &
            (adata.var['start'] <= cnv_end)
        ]
        
        # Determine the CNV effect: -1 for loss, +1 for gain
        cnv_effect = -1 if cnv_type == 'loss' else 1
        
        # Step 3: Set the corresponding entries in the CNV template matrix
        for gene in selected_genes.index:
            gene_index = gene_to_index[gene]
            cnv_template[i, gene_index] = cnv_effect
    
    # Convert the CNV template matrix to a DataFrame for easier interpretation
    cnv_template_df = pd.DataFrame(cnv_template, columns=adata.var_names)
    
    # Optionally, add the name of the CNV (gene name) as rownames in the DataFrame for reference
    if 'Gene name' in CNV_df.columns:
        cnv_template_df.index = CNV_df['Gene name'].values
    else:
        print("Warning: 'Gene name' column missing from CNV_df.")

    return cnv_template_df




def simulate_cnvs(adata, cnv_template_df, subclone_dict, cell_type_reference, cell_type_cnv, alpha=2):
    """ 
    Simulates CNVs by uniformly scaling gene expression values to mimic gains and losses.

    Parameters:
        - adata (AnnData): The AnnData object where the CNVs are to be simulated. Layer 'counts' should contain the raw counts where the CNVs are simulated. 
        - cnv_template_df (DataFrame): Templates for each CNV generated for the adata.
        - subclone_dict (dictionary): Specifies the subclones and their CNVs.
        - cell_type_reference (str): Column name in adata.obs indicating cell types.
        - cell_type_cnv (str or list): Specific cell types in which CNVs should be simulated.
        - alpha (float): Maximum amplitude for scaling.

    Returns:
        - adata (AnnData): Updated AnnData with simulated CNV data in a new layer.
    """
    # Prepare layers
    adata.layers['CNV_simulated'] = lil_matrix(adata.layers['counts'])
    adata.layers['CNV_GT'] = np.zeros(adata.X.shape)

    if isinstance(cell_type_cnv, str):
        cell_type_cnv = [cell_type_cnv]

    # Assign subclone labels
    cell_type_mask = adata.obs[cell_type_reference].isin(cell_type_cnv)
    num_cells = np.sum(cell_type_mask)
    subclone_names = list(subclone_dict.keys())

    adata.obs.loc[cell_type_mask, 'simulated_subclone'] = np.random.choice(
        subclone_names, size=num_cells, replace=True
    )
    adata.obs.loc[~cell_type_mask, 'simulated_subclone'] = "N"

    # Process subclones and apply CNV effects
    for subclone, cnvs in subclone_dict.items():
        if not cnvs:
            continue

        subclone_cells = (adata.obs['simulated_subclone'] == subclone).values
        if not np.any(subclone_cells):
            continue

        for cnv in cnvs:
            cnv_row = cnv_template_df.loc[cnv].values.flatten()

            for gene_idx, effect in enumerate(cnv_row):
                if effect == 0:
                    continue

                values_to_modify = adata.layers['CNV_simulated'][subclone_cells, gene_idx].toarray().flatten()

                rho = np.random.uniform(0, alpha)
                if effect == -1:
                    modified_values = values_to_modify / (1 + rho)
                    adata.layers['CNV_GT'][subclone_cells, gene_idx] = -1
                elif effect == 1:
                    modified_values = values_to_modify * (1 + rho)
                    adata.layers['CNV_GT'][subclone_cells, gene_idx] = 1

                # Clip and reshape
                modified_values = np.clip(modified_values, 0, None)
                adata.layers['CNV_simulated'][subclone_cells, gene_idx] = modified_values.reshape(-1, 1)

    # Convert back to CSR format for optimized downstream use
    adata.layers['CNV_simulated'] = csr_matrix(adata.layers['CNV_simulated'])

    return adata
