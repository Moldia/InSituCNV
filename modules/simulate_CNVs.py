import random
import pandas as pd
import numpy as np
import anndata



def generate_cnvs(CNV_dict, min_size, max_size, gene_info, save_csv = None):
    """ 
    This function generates copy number variations (CNVs) based on a dictionary (CNV_dict) of genes (keys) and whether they should be gain or loss (value). The size (bp) of the CNV is a randomly chosen between min_size and max_size. The gene will be in the center of the CNV, so half of the size (bp) is subtracted (start) and added (end) from the center of the gene position ('Gene end (bp)'- 'Gene start (bp)')/2), according to the gene_list. The function returns the CNV information as a DataFrame, specifying the gene name, chromosome, size (bp), type (gain/loss), start (bp), end (bp).

    Parameters:
        - CNV_dict (dictionary): Gene name (key) and whether they should be 'gain' or 'loss'.
        - min_size (nbr): minimum size (in bp) of the CNV.
        - max_size (nbr): maximum size (in bp) of the CNV.
        - gene_info (str): The path to the gene information from the *Ensmbl_BioMart_gene_info.txt* file, including  'Gene stable ID', 'Chromosome/scaffold name', 'Gene start (bp)', 'Gene end (bp)', 'Gene name' of the human genome GRCh38.

    Returns:
        - cnv_df (DataFrame): Compiling the gene name, chromosome, size, type, start, end
    """

    gene_info = pd.read_csv(gene_info)
    cnv_list = []

    for gene in CNV_dict:
        # Check if the gene is present in gene_info DataFrame
        if gene not in gene_info['Gene name'].values:
            print(f"Gene '{gene}' not found in gene_info DataFrame.")
            continue
        
        # Find gene details in the gene_info DataFrame
        gene_row = gene_info.loc[gene_info['Gene name'] == gene].iloc[0]
        
        # Calculate gene center
        gene_center = (gene_row['Gene end (bp)'] + gene_row['Gene start (bp)']) // 2
        
        # Randomly generate CNV size
        cnv_size = random.randint(min_size, max_size)
        
        # Calculate CNV start and end positions
        cnv_start = gene_center - cnv_size // 2
        cnv_end = gene_center + cnv_size // 2
        
        # Create CNV entry
        cnv = {
            'Gene name': gene,
            'Chromosome': gene_row['Chromosome/scaffold name'],
            'Size (bp)': cnv_size,
            'Type': CNV_dict[gene],
            'Start (bp)': cnv_start,
            'End (bp)': cnv_end
        }
        
        cnv_list.append(cnv)
    
    # Convert the list of CNV dictionaries to a DataFrame
    cnv_df = pd.DataFrame(cnv_list)

    if save_csv:
        cnv_df.to_csv(save_csv, index=None)
    
    return cnv_df







def create_cnv_template(adata, CNV_df):
    """ 
    This function generates a template for CNVs to an AnnData object

    Parameters:
        - adata (AnnData): The AnnData object to which the CNVs should fit.
        - CNV_df (DataFrame): CNVs generated by the generate_cnvs function. 

    Returns:
        - cnv_template_df (DataFrame): A CNV template where each CNV (gene name) has a -1/0/1 value for each gene in the adata.var

    """

    
    # Step 1: Order adata.var by chromosome and start position
    adata.var = adata.var.sort_values(by=['chromosome', 'start'])
    
    # Initialize the CNV template matrix with zeros
    cnv_template = np.zeros((len(CNV_df), len(adata.var_names)))

    # Create a mapping of gene names to indices in the sorted AnnData object
    gene_to_index = {gene: idx for idx, gene in enumerate(adata.var_names)}

    # Step 2: Loop through each CNV in the CNV_df
    for i, row in CNV_df.iterrows():
        chromosome = row['Chromosome']
        cnv_start = row['Start (bp)']
        cnv_end = row['End (bp)']
        cnv_type = row['Type']
        
        # Find the genes in the corresponding chromosome that fall within the CNV region
        selected_genes = adata.var[
            (adata.var['chromosome'] == chromosome) &
            (adata.var['start'] >= cnv_start) &
            (adata.var['start'] <= cnv_end)
        ]
        
        # Determine the CNV effect: -1 for loss, +1 for gain
        cnv_effect = -1 if cnv_type == 'loss' else 1
        
        # Step 3: Set the corresponding entries in the CNV template matrix
        for gene in selected_genes.index:
            gene_index = gene_to_index[gene]
            cnv_template[i, gene_index] = cnv_effect
    
    # Convert the CNV template matrix to a DataFrame for easier interpretation
    cnv_template_df = pd.DataFrame(cnv_template, columns=adata.var_names)
    
    # Optionally, add the name of the CNV (gene name) as rownames in the DataFrame for reference
    cnv_template_df.index = CNV_df['Gene name'].values

    return cnv_template_df







def simulate_cnvs(adata, cnv_template_df, subclone_dict):

    """ 
    This function creates a layer of the adata.X with simulated gains and losses according to the subclone dictionary. The cells are randomly distributed between subclones. 

    Parameters:
        - adata (AnnData): The AnnData object where the CNVs should be simulated
        - cnv_template_df (DataFrame): Templates for each CNV generated for the adata.
        - subclone_dict (dictionary): Specifies the subclones and their CNVs

    Returns:
        - adata (AnnData): The simulated AnnData object containing adata.obs['simulated_subclone'] and the simulated count matrix in an 'CNV_simulated' layer.

    """

    
    # Step 1: Create a new layer in adata to store the simulated CNV data
    adata.layers['CNV_simulated'] = adata.layers['counts'].copy()

    # Step 2: Randomly assign cells to subclones based on subclone_dict
    num_cells = adata.shape[0]
    subclone_names = list(subclone_dict.keys())
    adata.obs['simulated_subclone'] = np.random.choice(subclone_names, size=num_cells, replace=True)

    # Step 3: Apply CNVs to the expression data based on the assigned subclone
    for subclone, cnvs in subclone_dict.items():
        if not cnvs:
            # Skip if the CNV list is empty (as for normal subclone)
            continue
        
        # Get cells assigned to the current subclone
        subclone_cells = adata.obs['simulated_subclone'] == subclone
        
        for cnv in cnvs:
            # Extract the CNV effect for this gene from cnv_template_df
            cnv_row = cnv_template_df[cnv_template_df.index == cnv]
            cnv_effects = cnv_row.values.flatten()
            
            for gene_idx, effect in enumerate(cnv_effects):
                if effect == -1:
                    # Simulate loss of copy (binomial with p = 0.5)
                    adata.layers['CNV_simulated'][subclone_cells, gene_idx] = np.random.binomial(
                        adata.layers['CNV_simulated'][subclone_cells, gene_idx].astype(int), 0.5
                    )
                elif effect == 1:
                    # Simulate gain of copy (poisson with lambda = 1.5)
                    adata.layers['CNV_simulated'][subclone_cells, gene_idx] = np.random.poisson(
                        1.5 * adata.layers['CNV_simulated'][subclone_cells, gene_idx]
                    )

    return adata
